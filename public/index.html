<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBX Forearm Animator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #ffffff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: #333;
            border: 2px solid #ddd;
            z-index: 100;
            min-width: 300px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .slider-container label {
            width: 80px;
            font-size: 12px;
        }
        
        .slider-container input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        
        .slider-container .value {
            width: 50px;
            text-align: center;
            font-size: 12px;
            color: #FFD700;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            color: #333;
            border: 1px solid #ddd;
            z-index: 100;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 24px;
            z-index: 200;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: #333;
            outline: none;
            border-radius: 5px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .reset-btn {
            background: #FF5722;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        .reset-btn:hover {
            background: #D32F2F;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" class="loading">Loading 3D Model...</div>
        
        <div id="controls" style="display: none;">
            <h2>ðŸŽ® Forearm X-Rotation Animator</h2>
            
            <div class="control-group">
                <h3>ðŸ’ª Left Forearm (forearm.L)</h3>
                <div class="slider-container">
                    <label>Rotate X:</label>
                    <input type="range" id="forearmL-x" min="-100" max="100" value="0" step="1">
                    <span class="value" id="forearmL-x-value">0Â°</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3>ðŸ’ª Right Forearm (forearm.R)</h3>
                <div class="slider-container">
                    <label>Rotate X:</label>
                    <input type="range" id="forearmR-x" min="-100" max="100" value="0" step="1">
                    <span class="value" id="forearmR-x-value">0Â°</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Camera</h3>
                <div class="slider-container">
                    <label>Distance:</label>
                    <span class="value" id="camera-distance">--</span>
                </div>
                <div class="slider-container">
                    <label>Rotation:</label>
                    <span class="value" id="camera-rotation">--</span>
                </div>
            </div>
            <div class="control-group">
                <h3>Camera Height</h3>
                <div class="slider-container">
                    <label>Height (Y):</label>
                    <input type="range" id="camera-y" min="-2" max="2" value="2.00" step="0.01">
                    <span class="value" id="camera-y-value">2.00</span>
                </div>
            </div>
            <button class="reset-btn" onclick="resetPose()">Reset Pose</button>
        </div>
        
        <div id="status">
            <div id="status-text">Initializing...</div>
        </div>
    </div>

    <!-- Three.js ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Global variables
        let scene, camera, renderer, controls;
        let ground;
        let fbxModel, skeleton, bones = {};
        let forearmL, forearmR;
        let mixer, animations = [];
        
        // Initialize the 3D scene
        function init() {
            updateStatus("Setting up 3D scene...");
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.useLegacyLights = false;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(-5, 3, 2);
            scene.add(pointLight);
            
            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 2, 0);
            // Set initial camera azimuth and distance using spherical coordinates
            {
                const desiredAzimuthDeg = 25;
                const desiredDistance = 5.35;
                const offset = camera.position.clone().sub(controls.target);
                const spherical = new THREE.Spherical().setFromVector3(offset);
                spherical.radius = desiredDistance;
                spherical.theta = THREE.MathUtils.degToRad(desiredAzimuthDeg);
                const newOffset = new THREE.Vector3().setFromSpherical(spherical);
                camera.position.copy(controls.target).add(newOffset);
            }
            controls.addEventListener("change", updateCameraDistance);
            // Initialize display
            updateCameraDistance();
            
            // Add ground plane
            const groundGeometry = new THREE.PlaneGeometry(10, 10);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Hook up camera height slider (translates camera and target along Y)
            const camYSlider = document.getElementById('camera-y');
            const camYValue = document.getElementById('camera-y-value');
            if (camYSlider && camYValue) {
                // Initialize slider to current target.y
                camYSlider.value = controls.target.y.toFixed(2);
                camYValue.textContent = parseFloat(camYSlider.value).toFixed(2);
                const applyCamY = () => {
                    const y = parseFloat(camYSlider.value);
                    const offset = camera.position.clone().sub(controls.target);
                    controls.target.y = y;
                    camera.position.copy(controls.target).add(offset);
                    camYValue.textContent = y.toFixed(2);
                    updateCameraDistance();
                    controls.update();
                };
                camYSlider.addEventListener('input', applyCamY);
                applyCamY();
            }

            updateStatus("Loading 3D model...");
            loadFBXModel();
        }
        
        // Load the FBX model
        function loadFBXModel() {
            // Try GLB first (more web-compatible), then FBX as fallback
            const gltfLoader = new GLTFLoader();
            
            updateStatus("Attempting to load GLB model...");
            
            gltfLoader.load('/models/human_model_sit_possition_003.glb',
                function(gltf) {
                    updateStatus("Processing GLB model...");
                    
                    fbxModel = gltf.scene;
                    fbxModel.scale.setScalar(1); // GLB might have different scaling
                    fbxModel.position.y = 0;
                    
                    // Enable shadows
                    fbxModel.traverse(function(child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;

                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            const greyMaterials = materials.map(() => new THREE.MeshStandardMaterial({
                                color: 0x808080,
                                metalness: 0.05,
                                roughness: 0.65
                            }));
                            child.material = Array.isArray(child.material) ? greyMaterials : greyMaterials[0];
                        }
                    });
                    
                    scene.add(fbxModel);
                    
                    // Check for animations and set up sitting pose
                    console.log('GLB Animations found:', gltf.animations.length);
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(fbxModel);
                        animations = gltf.animations;
                        
                        // Log all animation names
                        gltf.animations.forEach((anim, index) => {
                            console.log(`Animation ${index}:`, anim.name);
                        });
                        
                        // Try to find and play sitting animation
                        const sittingAnim = gltf.animations.find(anim => 
                            anim.name.toLowerCase().includes('sit') || 
                            anim.name.toLowerCase().includes('pose')
                        ) || gltf.animations[0]; // Use first animation as fallback
                        
                        if (sittingAnim) {
                            const action = mixer.clipAction(sittingAnim);
                            action.play();
                            action.paused = true; // Pause at first frame to maintain pose
                            action.time = 0; // Set to first frame
                            console.log('Playing sitting animation:', sittingAnim.name);
                        }
                    } else {
                        console.log('No animations found in GLB file');
                    }
                    
                    // Find and store bone references
                    findBones();
                    
                    updateStatus("GLB Model loaded successfully!");
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('controls').style.display = 'block';
                    
                    setupControls();
                    animate();
                },
                function(progress) {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    updateStatus(`Loading GLB: ${percent}%`);
                },
                function(error) {
                    console.log('GLB failed, trying FBX...', error);
                    loadFBXFallback();
                }
            );
        }
        
        // Fallback to FBX if GLB fails
        function loadFBXFallback() {
            const fbxLoader = new FBXLoader();
            
            updateStatus("Loading FBX model...");
            
            fbxLoader.load('/models/human_model_sit_possition_002.fbx', 
                function(object) {
                    updateStatus("Processing FBX model...");
                    
                    fbxModel = object;
                    fbxModel.scale.setScalar(0.01); // Scale down if needed
                    fbxModel.position.y = 0;
                    
                    // Enable shadows
                    fbxModel.traverse(function(child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    scene.add(fbxModel);
                    
                    // Find and store bone references
                    findBones();
                    
                    updateStatus("FBX Model loaded successfully!");
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('controls').style.display = 'block';
                    
                    setupControls();
                    animate();
                },
                function(progress) {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    updateStatus(`Loading FBX: ${percent}%`);
                },
                function(error) {
                    console.error('Error loading both GLB and FBX:', error);
                    updateStatus("Error loading model. Check that files exist and server is running.");
                }
            );
        }
        
        // Find the forearm bones in the skeleton
        function findBones() {
            if (!fbxModel) return;
            
            fbxModel.traverse(function(child) {
                if (child.isBone || child.type === 'Bone') {
                    bones[child.name] = child;
                    
                    if (child.name === 'forearm.L' || child.name.includes('forearm') && child.name.includes('L')) {
                        forearmL = child;
                        console.log('Found Left Forearm:', child.name);
                    }
                    
                    if (child.name === 'forearm.R' || child.name.includes('forearm') && child.name.includes('R')) {
                        forearmR = child;
                        console.log('Found Right Forearm:', child.name);
                    }
                }
            });
            
            console.log('All bones found:', Object.keys(bones));
            console.log('Left Forearm:', forearmL?.name || 'Not found');
            console.log('Right Forearm:', forearmR?.name || 'Not found');
            
            // If no animations were found, try to manually create sitting pose
            if (!mixer && Object.keys(bones).length > 0) {
                applySittingPose();
            }
            
            if (!forearmL || !forearmR) {
                updateStatus("Warning: Could not find both forearm bones!");
            }
        }
        
        // Apply a manual sitting pose if no animations are available
        function applySittingPose() {
            console.log('Applying manual sitting pose...');
            
            // Try to find common bone names for sitting pose
            const hipBone = bones['hips'] || bones['Hips'] || bones['hip'] || bones['Hip'];
            const spinalBones = [
                bones['spine'] || bones['Spine'],
                bones['spine.001'] || bones['Spine1'],
                bones['spine.002'] || bones['Spine2']
            ].filter(Boolean);
            
            const leftThigh = bones['thigh.L'] || bones['LeftUpLeg'] || bones['thigh_L'];
            const rightThigh = bones['thigh.R'] || bones['RightUpLeg'] || bones['thigh_R'];
            
            const leftShin = bones['shin.L'] || bones['LeftLeg'] || bones['shin_L'];
            const rightShin = bones['shin.R'] || bones['RightLeg'] || bones['shin_R'];
            
            // Apply sitting rotations (approximate values)
            if (leftThigh) {
                leftThigh.rotation.x = THREE.MathUtils.degToRad(-90); // Bend thigh down
                console.log('Applied sitting rotation to left thigh');
            }
            
            if (rightThigh) {
                rightThigh.rotation.x = THREE.MathUtils.degToRad(-90); // Bend thigh down
                console.log('Applied sitting rotation to right thigh');
            }
            
            if (leftShin) {
                leftShin.rotation.x = THREE.MathUtils.degToRad(90); // Bend shin forward
                console.log('Applied sitting rotation to left shin');
            }
            
            if (rightShin) {
                rightShin.rotation.x = THREE.MathUtils.degToRad(90); // Bend shin forward
                console.log('Applied sitting rotation to right shin');
            }
            
            // Slightly lean the spine forward
            spinalBones.forEach((spine, index) => {
                if (spine) {
                    spine.rotation.x = THREE.MathUtils.degToRad(10 + index * 5);
                    console.log(`Applied spine rotation to spine bone ${index}`);
                }
            });
            
            updateStatus("Manual sitting pose applied");
        }
        
        // Setup control event listeners
        function setupControls() {
            // Left forearm controls (only X-axis since that's what exists in HTML)
            document.getElementById('forearmL-x').addEventListener('input', updateForearmRotation);
            
            // Right forearm controls (only X-axis since that's what exists in HTML)
            document.getElementById('forearmR-x').addEventListener('input', updateForearmRotation);
        }
        
        // Update forearm rotations
        function updateForearmRotation(event) {
            const id = event.target.id;
            const value = parseFloat(event.target.value);
            const radians = THREE.MathUtils.degToRad(value);
            
            // Update display value
            document.getElementById(id + '-value').textContent = value + 'Â°';
            
            // Apply rotation
            if (id === 'forearmL-x' && forearmL) {
                forearmL.rotation.x = radians;
            }
            
            if (id === 'forearmR-x' && forearmR) {
                forearmR.rotation.x = radians;
            }
        }
        
        // Reset pose to default
        function resetPose() {
            // Reset sliders
            const sliders = document.querySelectorAll('input[type="range"]');
            sliders.forEach(slider => {
                slider.value = 0;
                document.getElementById(slider.id + '-value').textContent = '0Â°';
            });
            
            // Reset bone rotations
            if (forearmL) {
                forearmL.rotation.set(0, 0, 0);
            }
            if (forearmR) {
                forearmR.rotation.set(0, 0, 0);
            }
        }
        
        // Make resetPose available globally
        window.resetPose = resetPose;
        
        function updateCameraDistance() {
            if (!camera || !controls) return;
            const distEl = document.getElementById("camera-distance");
            const rotEl = document.getElementById("camera-rotation");
            if (distEl) {
                const distance = camera.position.distanceTo(controls.target);
                distEl.textContent = distance.toFixed(2);
            }
            if (rotEl) {
                // Show azimuthal angle in degrees (horizontal rotation) with fallback
                const dx = camera.position.x - controls.target.x;
                const dz = camera.position.z - controls.target.z;
                const az = (typeof controls.getAzimuthalAngle === 'function')
                    ? controls.getAzimuthalAngle()
                    : Math.atan2(dx, dz);
                const azDeg = THREE.MathUtils.radToDeg(az);
                rotEl.textContent = Math.round(azDeg).toString();
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update animation mixer if it exists
            if (mixer) {
                mixer.update(0.016); // 60fps
            }
            
            controls.update();
            updateCameraDistance();
            renderer.render(scene, camera);
        }
        
        // Update status message
        function updateStatus(message) {
            document.getElementById('status-text').textContent = message;
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Start the application
        init();
    </script>
</body>
</html>


